<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Просмотрщик Пирамиды (v17 - Финальное выравнивание)</title>
    <style>
        body { margin: 0; background-color: #1a2a3a; color: #fff; font-family: sans-serif; }
        canvas { display: block; }
        .lil-gui { --background-color: #2a3a4a; --text-color: #eee; --widget-color: #4a5a6a; --hover-color: #5a6a7a; }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div class="info">
        <p><strong>Управление:</strong></p>
        <ul>
            <li><strong>ЛКМ + Движение:</strong> Вращение</li>
            <li><strong>Колесо мыши:</strong> Приближение/Отдаление</li>
            <li><strong>ПКМ + Движение:</strong> Перемещение</li>
        </ul>
        <p>Используйте панель управления справа для срезов и переключения видимостью объектов.</p>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        // --- Основные параметры ---
        const pyramidBase = 209;
        const pyramidHeight = 105;

        const centerRoomSize = 67;
        const sideRoomLength = 67;
        const sideRoomWidth = 34;
        const sideRoomHeight = 34;
        const newRoomSize = 14;
        const tinyRoomSize = 9;
        const microRoomSize = 4;
        const wallThickness = 1;
        const thickWallThickness = 3;

        let scene, camera, renderer, controls;
        let pyramidMesh, solidRoomsGroup, wallStructureGroup;
        
        const clippingPlanes = {
            x: new THREE.Plane(new THREE.Vector3(-1, 0, 0), pyramidBase / 2),
            y: new THREE.Plane(new THREE.Vector3(0, -1, 0), pyramidHeight),
            z: new THREE.Plane(new THREE.Vector3(0, 0, -1), pyramidBase / 2),
        };

        const params = {
            sliceX: pyramidBase / 2,
            sliceY: pyramidHeight,
            sliceZ: pyramidBase / 2,
            enableX: false,
            enableY: false,
            enableZ: false,
            showPyramid: true,
            showVoids: true,
            showWalls: false,
            pyramidOpacity: 0.2,
        };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2a3a);
            scene.fog = new THREE.Fog(0x1a2a3a, 500, 1000);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1500);
            camera.position.set(pyramidBase * 1.3, pyramidHeight * 1.6, pyramidBase * 1.3);
            camera.lookAt(0, pyramidHeight / 3, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.localClippingEnabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(150, 200, 50);
            scene.add(directionalLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, pyramidHeight / 3, 0);
            controls.update();
            controls.enableDamping = true;

            createPyramid();
            createInternalStructure();
            
            const axesHelper = new THREE.AxesHelper(pyramidBase);
            axesHelper.position.set(-pyramidBase/2 - 5, 0, -pyramidBase/2 - 5);
            scene.add(axesHelper);

            setupGUI();
            window.addEventListener('resize', onWindowResize);
        }

        function createPyramid() {
            const pyramidGeometry = new THREE.ConeGeometry(pyramidBase / Math.SQRT2, pyramidHeight, 4, 1, true);
            pyramidGeometry.rotateY(Math.PI / 4);
            
            const pyramidMaterial = new THREE.MeshPhongMaterial({
                color: 0xFADDAA,
                side: THREE.DoubleSide,
                clippingPlanes: Object.values(clippingPlanes),
                clipShadows: true,
                shininess: 10
            });
            pyramidMaterial.transparent = true;
            pyramidMaterial.opacity = params.pyramidOpacity;


            pyramidMesh = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
            pyramidMesh.position.y = pyramidHeight / 2;
            scene.add(pyramidMesh);
        }

        function createInternalStructure() {
            solidRoomsGroup = new THREE.Group();
            wallStructureGroup = new THREE.Group();

            const createMaterial = (color) => new THREE.MeshPhongMaterial({
                color,
                side: THREE.DoubleSide,
                clippingPlanes: Object.values(clippingPlanes),
                shininess: 20
            });
            
            const materials = {
                center: createMaterial(0xff8888),
                side: createMaterial(0x88aaff),
                new: createMaterial(0xf0a0f0),
                tiny: createMaterial(0xa0f0f0),
                micro: createMaterial(0xffff00),
                centerWall: createMaterial(0xffaaaa),
                sideWall: createMaterial(0x99dd99),
                newWall: createMaterial(0xd080d0),
                tinyWall: createMaterial(0x80d0d0),
                microWall: createMaterial(0xffffaa),
                thickWall: createMaterial(0x669966)
            };

            const t = wallThickness;
            const c_size = centerRoomSize;
            const c_half = c_size / 2;
            const sr_l = sideRoomLength;
            const sr_l_half = sr_l / 2;
            const sr_w = sideRoomWidth;
            const sr_w_half = sr_w / 2;
            const sr_h = sideRoomHeight;
            const nr_s = newRoomSize;
            const nr_s_half = nr_s / 2;
            const tr_s = tinyRoomSize;
            const tr_s_half = tr_s / 2;
            const mr_s = microRoomSize;
            const mr_s_half = mr_s / 2;
            const tw = thickWallThickness;
            const tw_half = tw / 2;

            // --- 1. Определение всех пустот ---
            const rooms = [];
            const new_rooms = [];
            const tiny_rooms = [];
            
            rooms.push({ x: 0, y: c_half, z: 0, w: c_size, h: c_size, d: c_size, type: 'center' });
            const sideRoomOffsetY = sr_h / 2;
            const sideRoomOffset = c_half + t + sr_w_half;
            rooms.push({ x: 0, y: sideRoomOffsetY, z: sideRoomOffset, w: sr_l, h: sr_h, d: sr_w, type: 'side' });
            rooms.push({ x: 0, y: sideRoomOffsetY, z: -sideRoomOffset, w: sr_l, h: sr_h, d: sr_w, type: 'side' });
            rooms.push({ x: sideRoomOffset, y: sideRoomOffsetY, z: 0, w: sr_w, h: sr_h, d: sr_l, type: 'side' });
            rooms.push({ x: -sideRoomOffset, y: sideRoomOffsetY, z: 0, w: sr_w, h: sr_h, d: sr_l, type: 'side' });
            
            const setA_Y = c_size + t + nr_s_half;
            const setA_Offset = tw_half + nr_s_half;
            [[setA_Offset, setA_Offset], [setA_Offset, -setA_Offset], [-setA_Offset, setA_Offset], [-setA_Offset, -setA_Offset]].forEach(([x, z]) => {
                new_rooms.push({ x, y: setA_Y, z, w: nr_s, h: nr_s, d: nr_s, type: 'new' });
            });
            
            const setB_Y = sr_h + t + nr_s_half;
            const setB_X_pos = tw_half + nr_s_half;
            const setB_Z_pos = c_half + t + nr_s_half;
            [[setB_X_pos, setB_Z_pos], [-setB_X_pos, setB_Z_pos], [setB_X_pos, -setB_Z_pos], [-setB_X_pos, -setB_Z_pos]].forEach(([x, z]) => {
                new_rooms.push({ x, y: setB_Y, z, w: nr_s, h: nr_s, d: nr_s, type: 'new' });
                new_rooms.push({ x: z, y: setB_Y, z: x, w: nr_s, h: nr_s, d: nr_s, type: 'new' });
            });

            // ИСПРАВЛЕНО: Убрана лишняя толщина стены 't' для комнат на "полу"
            const setC_Y = nr_s_half;
            const setC_pos = sr_l_half + t + nr_s_half;
             [[setC_pos, setC_pos], [setC_pos, -setC_pos], [-setC_pos, setC_pos], [-setC_pos, -setC_pos]].forEach(([x, z]) => {
                new_rooms.push({ x, y: setC_Y, z, w: nr_s, h: nr_s, d: nr_s, type: 'new' });
            });

            // ИСПРАВЛЕНО: Убрана лишняя толщина стены 't' для комнат на "полу"
            const setD_Y = nr_s_half;
            const setD_center_offset = tw_half + nr_s_half;
            const setD_outer_offset = c_half + t + sr_w + t + nr_s_half;
            [[setD_center_offset, setD_outer_offset], [-setD_center_offset, setD_outer_offset], [setD_center_offset, -setD_outer_offset], [-setD_center_offset, -setD_outer_offset]].forEach(([x, z]) => {
                new_rooms.push({ x, y: setD_Y, z, w: nr_s, h: nr_s, d: nr_s, type: 'new' });
                new_rooms.push({ x: z, y: setD_Y, z: x, w: nr_s, h: nr_s, d: nr_s, type: 'new' });
            });
            
            rooms.push(...new_rooms);

            // Set E (tiny rooms)
            new_rooms.forEach(nr => {
                const {x: nx, y: ny, z: nz} = nr;
                const sign_x = Math.sign(nx) || 1;
                const sign_z = Math.sign(nz) || 1;
                
                const y_top = ny + nr_s_half + t + tr_s_half;
                const x_top = nx - sign_x * (nr_s_half - tr_s_half);
                const z_top = nz - sign_z * (nr_s_half - tr_s_half);
                tiny_rooms.push({ x: x_top, y: y_top, z: z_top, w: tr_s, h: tr_s, d: tr_s, type: 'tiny' });

                const y_side = ny - nr_s_half + tr_s_half;
                
                const x_side1 = nx + sign_x * (nr_s_half + t + tr_s_half);
                const z_side1 = nz - sign_z * (nr_s_half - tr_s_half);
                tiny_rooms.push({ x: x_side1, y: y_side, z: z_side1, w: tr_s, h: tr_s, d: tr_s, type: 'tiny' });

                const x_side2 = nx - sign_x * (nr_s_half - tr_s_half);
                const z_side2 = nz + sign_z * (nr_s_half + t + tr_s_half);
                tiny_rooms.push({ x: x_side2, y: y_side, z: z_side2, w: tr_s, h: tr_s, d: tr_s, type: 'tiny' });
            });
            rooms.push(...tiny_rooms);

            // Set F (micro rooms)
            tiny_rooms.forEach(tr => {
                const {x: tx, y: ty, z: tz} = tr;
                const sign_x = Math.sign(tx) || 1;
                const sign_z = Math.sign(tz) || 1;
                
                const y_top = ty + tr_s_half + t + mr_s_half;
                const x_top = tx - sign_x * (tr_s_half - mr_s_half);
                const z_top = tz - sign_z * (tr_s_half - mr_s_half);
                rooms.push({ x: x_top, y: y_top, z: z_top, w: mr_s, h: mr_s, d: mr_s, type: 'micro' });

                const y_side = ty - tr_s_half + mr_s_half;

                const x_side1 = tx + sign_x * (tr_s_half + t + mr_s_half);
                const z_side1 = tz - sign_z * (tr_s_half - mr_s_half);
                rooms.push({ x: x_side1, y: y_side, z: z_side1, w: mr_s, h: mr_s, d: mr_s, type: 'micro' });

                const x_side2 = tx - sign_x * (tr_s_half - mr_s_half);
                const z_side2 = tz + sign_z * (tr_s_half + t + mr_s_half);
                rooms.push({ x: x_side2, y: y_side, z: z_side2, w: mr_s, h: mr_s, d: mr_s, type: 'micro' });
            });
            
            // --- 2. Создание геометрии ---
            rooms.forEach(r => {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(r.w, r.h, r.d), materials[r.type]);
                mesh.position.set(r.x, r.y, r.z);
                solidRoomsGroup.add(mesh);
            });
            
            // --- 3. Генерация стен ---
            const wallGeometries = {
                centerWall: [], sideWall: [], newWall: [], tinyWall: [], microWall: [], thickWall: []
            };

            const createWalledBoxGeos = (r, t) => {
                const {x, y, z, w, h, d, type} = r;
                const matType = type + 'Wall';
                const geos = wallGeometries[matType] || wallGeometries.sideWall;

                geos.push(new THREE.BoxGeometry(w + 2*t, t, d + 2*t).translate(x, y - h/2 - t/2, z));
                geos.push(new THREE.BoxGeometry(w + 2*t, t, d + 2*t).translate(x, y + h/2 + t/2, z));
                geos.push(new THREE.BoxGeometry(t, h, d).translate(x - w/2 - t/2, y, z));
                geos.push(new THREE.BoxGeometry(t, h, d).translate(x + w/2 + t/2, y, z));
                geos.push(new THREE.BoxGeometry(w, h, t).translate(x, y, z - d/2 - t/2));
                geos.push(new THREE.BoxGeometry(w, h, t).translate(x, y, z + d/2 + t/2));
            };
            rooms.forEach(r => createWalledBoxGeos(r, t));
            
            const getPyramidHeightAt = (x, z) => pyramidHeight - Math.max(Math.abs(x), Math.abs(z)) * (pyramidHeight / (pyramidBase / 2));
            const max_coord = Math.floor(pyramidBase / 2);
            for (let i = -max_coord; i <= max_coord; i++) {
                const top_y_z = getPyramidHeightAt(tw_half, i);
                let bottom_y_z = 0;
                if (Math.abs(i) < c_half) bottom_y_z = c_size;
                else if (Math.abs(i) > c_half + t && Math.abs(i) < c_half + t + sr_w) bottom_y_z = sr_h;
                const h_z = top_y_z - bottom_y_z;
                if(h_z > 0) wallGeometries.thickWall.push(new THREE.BoxGeometry(tw, h_z, 1).translate(0, bottom_y_z + h_z / 2, i));

                if (Math.abs(i) < tw_half) continue;
                const top_y_x = getPyramidHeightAt(i, tw_half);
                let bottom_y_x = 0;
                if (Math.abs(i) < c_half) bottom_y_x = c_size;
                else if (Math.abs(i) > c_half + t && Math.abs(i) < c_half + t + sr_w) bottom_y_x = sr_h;
                const h_x = top_y_x - bottom_y_x;
                if(h_x > 0) wallGeometries.thickWall.push(new THREE.BoxGeometry(1, h_x, tw).translate(i, bottom_y_x + h_x / 2, 0));
            }

            for (const [matName, geos] of Object.entries(wallGeometries)) {
                if (geos.length > 0) {
                    const mergedGeo = BufferGeometryUtils.mergeGeometries(geos);
                    if (mergedGeo) {
                        const mesh = new THREE.Mesh(mergedGeo, materials[matName]);
                        wallStructureGroup.add(mesh);
                    }
                }
            }

            wallStructureGroup.visible = params.showWalls;
            solidRoomsGroup.visible = params.showVoids;
            scene.add(solidRoomsGroup);
            scene.add(wallStructureGroup);
        }

        function setupGUI() {
            const gui = new GUI();
            gui.title("Панель Управления");

            const viewFolder = gui.addFolder('Режим отображения');
            viewFolder.add(params, 'showPyramid').name('Пирамида').onChange(val => pyramidMesh.visible = val);
            viewFolder.add(params, 'pyramidOpacity', 0, 1).name('Прозрачность').onChange(val => pyramidMesh.material.opacity = val);
            viewFolder.add(params, 'showVoids').name('Показать пустоты').onChange(val => solidRoomsGroup.visible = val);
            viewFolder.add(params, 'showWalls').name('Показать стены').onChange(val => wallStructureGroup.visible = val);

            const clippingFolder = gui.addFolder('Срезы');
            clippingFolder.add(params, 'enableY').name('Срез Y (Верх-Низ)').onChange(val => clippingPlanes.y.constant = val ? params.sliceY : pyramidHeight);
            clippingFolder.add(params, 'sliceY', 0, pyramidHeight).name('Высота среза Y').onChange(val => { if(params.enableY) clippingPlanes.y.constant = val; });
            clippingFolder.add(params, 'enableX').name('Срез X').onChange(val => clippingPlanes.x.constant = val ? params.sliceX : pyramidBase / 2);
            clippingFolder.add(params, 'sliceX', -pyramidBase / 2, pyramidBase / 2).name('Позиция среза X').onChange(val => { if(params.enableX) clippingPlanes.x.constant = val; });
            clippingFolder.add(params, 'enableZ').name('Срез Z').onChange(val => clippingPlanes.z.constant = val ? params.sliceZ : pyramidBase / 2);
            clippingFolder.add(params, 'sliceZ', -pyramidBase / 2, pyramidBase / 2).name('Позиция среза Z').onChange(val => { if(params.enableZ) clippingPlanes.z.constant = val; });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
