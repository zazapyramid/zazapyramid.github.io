<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Просмотрщик Пирамиды (v10 - Финал)</title>
    <style>
        body { margin: 0; background-color: #1a2a3a; color: #fff; font-family: sans-serif; }
        canvas { display: block; }
        .lil-gui { --background-color: #2a3a4a; --text-color: #eee; --widget-color: #4a5a6a; --hover-color: #5a6a7a; }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div class="info">
        <p><strong>Управление:</strong></p>
        <ul>
            <li><strong>ЛКМ + Движение:</strong> Вращение</li>
            <li><strong>Колесо мыши:</strong> Приближение/Отдаление</li>
            <li><strong>ПКМ + Движение:</strong> Перемещение</li>
        </ul>
        <p>Используйте панель управления справа для срезов и переключения видимостью объектов.</p>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- Основные параметры ---
        const pyramidBase = 209;
        const pyramidHeight = 105;

        const centerRoomSize = 67;
        const sideRoomLength = 67;
        const sideRoomWidth = 34;
        const sideRoomHeight = 34;
        const newRoomSize = 14;
        const wallThickness = 1;
        const thickWallThickness = 3;

        let scene, camera, renderer, controls;
        let pyramidMesh, solidRoomsGroup, wallStructureGroup;
        
        const clippingPlanes = {
            x: new THREE.Plane(new THREE.Vector3(-1, 0, 0), pyramidBase / 2),
            y: new THREE.Plane(new THREE.Vector3(0, -1, 0), pyramidHeight),
            z: new THREE.Plane(new THREE.Vector3(0, 0, -1), pyramidBase / 2),
        };

        const params = {
            sliceX: pyramidBase / 2,
            sliceY: pyramidHeight,
            sliceZ: pyramidBase / 2,
            enableX: false,
            enableY: false,
            enableZ: false,
            showPyramid: true,
            showVoids: true, // Новая опция
            showAsWalls: false,
            pyramidOpacity: 0.2,
        };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2a3a);
            scene.fog = new THREE.Fog(0x1a2a3a, 500, 1000);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1500);
            camera.position.set(pyramidBase * 1.2, pyramidHeight * 1.5, pyramidBase * 1.2);
            camera.lookAt(0, pyramidHeight / 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.localClippingEnabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(150, 200, 50);
            scene.add(directionalLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, pyramidHeight / 3, 0);
            controls.update();
            controls.enableDamping = true;

            createPyramid();
            createInternalStructure();
            
            const axesHelper = new THREE.AxesHelper(pyramidBase);
            axesHelper.position.set(-pyramidBase/2 - 5, 0, -pyramidBase/2 - 5);
            scene.add(axesHelper);

            setupGUI();
            window.addEventListener('resize', onWindowResize);
        }

        function createPyramid() {
            const pyramidGeometry = new THREE.ConeGeometry(pyramidBase / Math.SQRT2, pyramidHeight, 4, 1, true);
            pyramidGeometry.rotateY(Math.PI / 4);
            
            const pyramidMaterial = new THREE.MeshPhongMaterial({
                color: 0xFADDAA,
                side: THREE.DoubleSide,
                clippingPlanes: Object.values(clippingPlanes),
                clipShadows: true,
                shininess: 10
            });
            pyramidMaterial.transparent = true;
            pyramidMaterial.opacity = params.pyramidOpacity;


            pyramidMesh = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
            pyramidMesh.position.y = pyramidHeight / 2;
            scene.add(pyramidMesh);
        }

        function createInternalStructure() {
            solidRoomsGroup = new THREE.Group();
            wallStructureGroup = new THREE.Group();

            const createMaterial = (color) => new THREE.MeshPhongMaterial({
                color,
                side: THREE.DoubleSide,
                clippingPlanes: Object.values(clippingPlanes),
                shininess: 20
            });
            
            const solidMaterial = createMaterial(0x88aaff);
            const wallMaterial = createMaterial(0x99dd99);
            const newRoomSolidMaterial = createMaterial(0xf0a0f0);
            const newRoomWallMaterial = createMaterial(0xd080d0);
            const thickWallMaterial = createMaterial(0x669966);

            const addSolid = (w, h, d, x, y, z, material, parent) => {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), material);
                mesh.position.set(x, y, z);
                parent.add(mesh);
            };

            const t = wallThickness;
            const c_size = centerRoomSize;
            const c_half = c_size / 2;
            const sr_l = sideRoomLength;
            const sr_l_half = sr_l / 2;
            const sr_w = sideRoomWidth;
            const sr_w_half = sr_w / 2;
            const sr_h = sideRoomHeight;
            const nr_s = newRoomSize;
            const nr_s_half = nr_s / 2;
            const tw = thickWallThickness;
            const tw_half = tw / 2;

            // --- 1. Базовые комнаты (Solid View) ---
            const centerRoomSolidMat = createMaterial(0xff8888);
            addSolid(c_size, c_size, c_size, 0, c_size / 2, 0, centerRoomSolidMat, solidRoomsGroup);
            const sideRoomOffsetY = sr_h / 2;
            const sideRoomOffset = c_half + t + sr_w_half;
            addSolid(sr_l, sr_h, sr_w, 0, sideRoomOffsetY, sideRoomOffset, solidMaterial, solidRoomsGroup);
            addSolid(sr_l, sr_h, sr_w, 0, sideRoomOffsetY, -sideRoomOffset, solidMaterial, solidRoomsGroup);
            addSolid(sr_w, sr_h, sr_l, sideRoomOffset, sideRoomOffsetY, 0, solidMaterial, solidRoomsGroup);
            addSolid(sr_w, sr_h, sr_l, -sideRoomOffset, sideRoomOffsetY, 0, solidMaterial, solidRoomsGroup);

            // --- 2. Новые комнаты (Solid View) с ИСПРАВЛЕННЫМИ КООРДИНАТАМИ ---
            // Set A: 4 комнаты над центральной
            const setA_Y = c_size + t + nr_s_half;
            const setA_Offset = tw_half + nr_s_half; // Исправлено
            addSolid(nr_s, nr_s, nr_s, setA_Offset, setA_Y, setA_Offset, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, setA_Offset, setA_Y, -setA_Offset, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, -setA_Offset, setA_Y, setA_Offset, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, -setA_Offset, setA_Y, -setA_Offset, newRoomSolidMaterial, solidRoomsGroup);
            
            // Set B: 8 комнат над боковыми
            const setB_Y = sr_h + t + nr_s_half;
            const setB_X_pos = tw_half + nr_s_half; // Исправлено
            const setB_Z_pos = c_half + t + nr_s_half; // Это расстояние от стены боковой комнаты, не от толстой стены
            addSolid(nr_s, nr_s, nr_s, setB_X_pos, setB_Y, setB_Z_pos, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, -setB_X_pos, setB_Y, setB_Z_pos, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, setB_X_pos, setB_Y, -setB_Z_pos, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, -setB_X_pos, setB_Y, -setB_Z_pos, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, setB_Z_pos, setB_Y, setB_X_pos, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, -setB_Z_pos, setB_Y, setB_X_pos, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, setB_Z_pos, setB_Y, -setB_X_pos, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, -setB_Z_pos, setB_Y, -setB_X_pos, newRoomSolidMaterial, solidRoomsGroup);

            // Set C: 4 комнаты на полу в углах
            const setC_Y = t + nr_s_half;
            const setC_pos = sr_l_half + t + nr_s_half;
            addSolid(nr_s, nr_s, nr_s, setC_pos, setC_Y, setC_pos, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, -setC_pos, setC_Y, setC_pos, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, setC_pos, setC_Y, -setC_pos, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, -setC_pos, setC_Y, -setC_pos, newRoomSolidMaterial, solidRoomsGroup);

            // Set D: 8 крайних комнат на полу
            const setD_Y = nr_s_half;
            const setD_center_offset = tw_half + nr_s_half; // Исправлено
            const setD_outer_offset = c_half + t + sr_w + t + nr_s_half;
            addSolid(nr_s, nr_s, nr_s,  setD_center_offset, setD_Y,  setD_outer_offset, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, -setD_center_offset, setD_Y,  setD_outer_offset, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s,  setD_center_offset, setD_Y, -setD_outer_offset, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, -setD_center_offset, setD_Y, -setD_outer_offset, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s,  setD_outer_offset, setD_Y,  setD_center_offset, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, -setD_outer_offset, setD_Y,  setD_center_offset, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s,  setD_outer_offset, setD_Y, -setD_center_offset, newRoomSolidMaterial, solidRoomsGroup);
            addSolid(nr_s, nr_s, nr_s, -setD_outer_offset, setD_Y, -setD_center_offset, newRoomSolidMaterial, solidRoomsGroup);


            // --- 3. Генерация всех стен для режима "Показать стены" ---
            const createWalledBox = (innerW, innerH, innerD, material, t = 1) => {
                const group = new THREE.Group();
                // Пол и Потолок
                group.add(new THREE.Mesh(new THREE.BoxGeometry(innerW + 2 * t, t, innerD + 2 * t)).translateY(-innerH / 2 - t / 2));
                group.add(new THREE.Mesh(new THREE.BoxGeometry(innerW + 2 * t, t, innerD + 2 * t)).translateY(innerH / 2 + t / 2));
                // Стены по X
                group.add(new THREE.Mesh(new THREE.BoxGeometry(t, innerH, innerD)).translateX(-innerW / 2 - t / 2));
                group.add(new THREE.Mesh(new THREE.BoxGeometry(t, innerH, innerD)).translateX(innerW / 2 + t / 2));
                // Стены по Z
                group.add(new THREE.Mesh(new THREE.BoxGeometry(innerW, innerH, t)).translateZ(-innerD / 2 - t / 2));
                group.add(new THREE.Mesh(new THREE.BoxGeometry(innerW, innerH, t)).translateZ(innerD / 2 + t / 2));
                group.children.forEach(child => child.material = material);
                return group;
            };

            solidRoomsGroup.children.forEach(child => {
                const { width, height, depth } = child.geometry.parameters;
                const pos = child.position;
                let mat;
                if (child.material.color.getHex() === 0xff8888) {
                    mat = wallMaterial.clone(); mat.color.set(0xffaaaa);
                } else if (child.material === solidMaterial) {
                    mat = wallMaterial;
                } else {
                    mat = newRoomWallMaterial;
                }
                const walledBox = createWalledBox(width, height, depth, mat, t);
                walledBox.position.copy(pos);
                wallStructureGroup.add(walledBox);
            });
            
            // --- 4. Толстые стены ---
            const getPyramidHeightAt = (x, z) => pyramidHeight - Math.max(Math.abs(x), Math.abs(z)) * (pyramidHeight / (pyramidBase / 2));
            const addThickWallSegment = (w, h, d, x, y, z) => {
                if (h < 1) return;
                addSolid(w, h, d, x, y, z, thickWallMaterial, wallStructureGroup);
            };

            const max_coord = Math.floor(pyramidBase / 2);

            for (let i = -max_coord; i <= max_coord; i++) {
                // Стена вдоль оси Z
                const top_y_z = getPyramidHeightAt(tw_half, i);
                let bottom_y_z = 0;
                if (Math.abs(i) < c_half) bottom_y_z = c_size;
                else if (Math.abs(i) > c_half + t && Math.abs(i) < c_half + t + sr_w) bottom_y_z = sr_h;
                addThickWallSegment(tw, top_y_z - bottom_y_z, 1, 0, bottom_y_z + (top_y_z - bottom_y_z) / 2, i);

                // Стена вдоль оси X
                if (Math.abs(i) < tw_half) continue;
                const top_y_x = getPyramidHeightAt(i, tw_half);
                let bottom_y_x = 0;
                if (Math.abs(i) < c_half) bottom_y_x = c_size;
                else if (Math.abs(i) > c_half + t && Math.abs(i) < c_half + t + sr_w) bottom_y_x = sr_h;
                addThickWallSegment(1, top_y_x - bottom_y_x, tw, i, bottom_y_x + (top_y_x - bottom_y_x) / 2, 0);
            }

            wallStructureGroup.visible = params.showAsWalls;
            solidRoomsGroup.visible = params.showVoids;
            scene.add(solidRoomsGroup);
            scene.add(wallStructureGroup);
        }

        function setupGUI() {
            const gui = new GUI();
            gui.title("Панель Управления");

            const viewFolder = gui.addFolder('Режим отображения');
            viewFolder.add(params, 'showPyramid').name('Пирамида').onChange(val => pyramidMesh.visible = val);
            viewFolder.add(params, 'pyramidOpacity', 0, 1).name('Прозрачность').onChange(val => pyramidMesh.material.opacity = val);
            viewFolder.add(params, 'showVoids').name('Показать пустоты').onChange(val => solidRoomsGroup.visible = val);
            viewFolder.add(params, 'showAsWalls').name('Показать стены').onChange(val => wallStructureGroup.visible = val);

            const clippingFolder = gui.addFolder('Срезы');
            clippingFolder.add(params, 'enableY').name('Срез Y (Верх-Низ)').onChange(val => clippingPlanes.y.constant = val ? params.sliceY : pyramidHeight);
            clippingFolder.add(params, 'sliceY', 0, pyramidHeight).name('Высота среза Y').onChange(val => { if(params.enableY) clippingPlanes.y.constant = val; });
            clippingFolder.add(params, 'enableX').name('Срез X').onChange(val => clippingPlanes.x.constant = val ? params.sliceX : pyramidBase / 2);
            clippingFolder.add(params, 'sliceX', -pyramidBase / 2, pyramidBase / 2).name('Позиция среза X').onChange(val => { if(params.enableX) clippingPlanes.x.constant = val; });
            clippingFolder.add(params, 'enableZ').name('Срез Z').onChange(val => clippingPlanes.z.constant = val ? params.sliceZ : pyramidBase / 2);
            clippingFolder.add(params, 'sliceZ', -pyramidBase / 2, pyramidBase / 2).name('Позиция среза Z').onChange(val => { if(params.enableZ) clippingPlanes.z.constant = val; });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
